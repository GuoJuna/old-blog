---
layout: post
title: JVM 学习笔记
category: java
tags: [java,JVM]
excerpt: JVM 学习笔记
---


## JVM 整体组成可分为以下四个部分：
>- 类加载器（ClassLoader）
>- 运行时数据区（Runtime Data Area）
>- 执行引擎（Execution Engine）
>- 本地库接口（Native Interface）

## 类的加载

### 什么是类的加载
   >类的加载指的是将类.class文件中的二进制数据读入到内存中,将其放在运行时数据区的方法区内,然后在堆区创建一个java.lang.Class对象,用来封装类在方法区内的数据结构.类的加载的最终产品是位于堆区的Class对象Class队形封装了类在方法区内的数据结构,并且向java程序员提供了访问方法区内的数据结构结构的接口.
### 类的生命周期
   >类的生命周期包括加载,连接,初始化,使用和卸载.
    1. 加载，查找并加载类的二进制数据，在Java堆中也创建一个java.lang.Class类的对象
    2. 连接，连接又包含三块内容：验证、准备、初始化。1）验证，文件格式、元数据、字节码、符号引用验证；2）准备，为类的静态变量分配内存，并将其初始化为默认值；3）解析，把类中的符号引用转换为直接引用
    3. 初始化，为类的静态变量赋予正确的初始值
    4. 使用，new出对象程序中使用
    5. 卸载，执行垃圾回收
### 类加载器
   - 启动类加载器
   >Bootstrap ClassLoader，负责加载存放在JDK\jre\lib(JDK代表JDK的安装目录，下同)下，或被-Xbootclasspath参数指定的路径中的，并且能被虚拟机识别的类库
   - 扩展类加载器
   >Extension ClassLoader，该加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载DK\jre\lib\ext目录中，或者由java.ext.dirs系统变量指定的路径中的所有类库（如javax.*开头的类），开发者可以直接使用扩展类加载器。
   - 应用程序类加载器
   >Application ClassLoader，该类加载器由sun.misc.Launcher$AppClassLoader来实现，它负责加载用户类路径（ClassPath）所指定的类，开发者可以直接使用该类加载器类加载机制   
### 类加载机制
   - 全盘负责
   >当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入
   - 父类委托
   >先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类
   - 缓存机制
   >缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效

## JVM内存结构
   - Java堆（Heap）
   >是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。
   - 方法区（Method Area）
   >方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。
   - 程序计数器（Program Counter Register）
   >程序计数器（Program Counter Register）是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器。
   - JVM栈（JVM Stacks）
   >与程序计数器一样，Java虚拟机栈（Java Virtual Machine Stacks）也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。
   - 本地方法栈（Native Method Stacks）
   >本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native方法服务。 
   >方法区和堆是所有线程共享的内存区域；而java栈、本地方法栈和程序计数器是运行是线程私有的内存区域。
##对象分配原则    
   >- 对象优先分配在Eden区，如果Eden区没有足够的空间时，虚拟机执行一次Minor GC。
   >- 大对象直接进入老年代（大对象是指需要大量连续内存空间的对象）。这样做的目的是避免在Eden区和两个Survivor区之间发生大量的内存拷贝（新生代采用复制算法收集内存）。
   >- 长期存活的对象进入老年代。虚拟机为每个对象定义了一个年龄计数器，如果对象经过了1次Minor GC那么对象会进入Survivor区，之后每经过一次Minor GC那么对象的年龄加1，知道达到阀值对象进入老年区。
   >- 动态判断对象的年龄。如果Survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代。
   >- 空间分配担保。每次进行Minor GC时，JVM会计算Survivor区移至老年区的对象的平均大小，如果这个值大于老年区的剩余值大小则进行一次Full GC，如果小于检查HandlePromotionFailure设置，如果true则只进行Monitor GC,如果false则进行Full GC。 
## 对象存活判断 
   - 引用计数
   >每个对象有一个引用计数属性,新增一个引用是计数就1,计数为0时可以回收.此方法简单,无法解决对象相互循环引用的问题 
   - 可达性分析
   >从GC Roots开始向下搜索,搜索所走过的路径称为引用链.当一个对象到GC Roots没有任何引用链相连时,则证明此对象是不可用的.不可达对象
## 垃圾收集算法
   - 标记-清除算法    
   - 复制算法
   - 标记-压缩算法
   - 分代收集算法
   >把java堆分为新生代和老年代, 新生代选用复制算法,老年代采用标记-清理算法或标记-整理
## 垃圾收集器 
   >如果说收集算法是内存回收的方法论, 垃圾收集器就是内存回收的集体实现
### Serial收集器(串行收集器)
   > 串行收集器是最古老,最稳定以及效率高的收集器,可能会产生较长的停顿,只使用一个线程去回收.新生代,老年代使用串行回收;新生代复制算法,老年代标记-清理算法; 垃圾收集的过程会stop the world(服务暂停)
    ParNew 收集器是serial收集器的多线程版本. 新生代并行,老年代串行;
### Parallel收集(并行收集器)
   > Parallel scavenge收集器类似于ParNew收集器, parallel收集器更关注系统的吞吐量.
### Parallel Old收集器
   > Parallel Old是Parallel Scavenge收集器的老年代版本,使用多线程和标记-整理算法
### CMS收集器
   > cms(Concurrent mark Sweep)收集器是一种以获取最短回收停顿时间为目标的收集器.
    
   > 整个过程包括4个步骤:
   > 1. 初始标记
   > 2. 并发标记
   > 3. 重新标记
   > 4. 并发清除
### G1收集器
   >与CMS收集器相比G1收集器特点:
    1.空间整合 g1收集器采用标记整理算法, 不会产生空间碎片. 分配打对象时不会因为无法找到连续空间而提前触发下一次GC.
    2.可预测停顿 能让使用者明确指定在一个长度为N毫秒的时间片段内,消耗在垃圾收集上的时间不得超过Nh毫秒.
    